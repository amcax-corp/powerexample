/// @file      NMAPIModel.hpp
/// @brief     Class of NextMesh Model
/// @details   Operations related to NextMesh-Model, Geometry and Mesh
/// Generation
/// @copyright Copyright (c) 2023 Hefei Jiushao Intelligent Technology Co., Ltd.
/// All rights reserved.
/// @par       This file is part of AMCAX kernel.
#pragma once
#include <iostream>
#include <nextmesh/NMBlock.hpp>
#include <nextmesh/NMMesh.hpp>
#include <set>

namespace AMCAX {
namespace NextMesh {

class Model;
/**
 * @brief Class of model in NextMesh
 */
class NMAPIModel
{
public:
	AMCAX_API NMAPIModel();

	/**
	 * @brief Load a cad model represented by AMCAX TopoShape. Note: this
	 * import method does not specify any entity tags, which will be generated
	 * internally. The tag counts from 1 in each dimension
	 * @param shapes The shapes generated by AMCAX-Kernel
	 * @param replace If true, the existing model is replaced; otherwise, the
	 * shapes are added to the existing model
	 */
	AMCAX_API void ImportModel(const std::vector<NMShape> &shapes,
	                           const bool                  replace = true);

	/**
	 * @brief Load a cad model with associated tags. Two principles: 1. The tags
	 * of different entities in the same dimension must be different; 2. All low
	 * dimensional entities contained within high-dimensional entities must be
	 * tagged.
	 * @param shape The CAD shape, considered from a decomposition perspective.
	 * @param replace A flag indicating whether to replace the existing model. If
	 * set to true, the existing model is replaced; if false, the shapes are
	 * merged with the existing model. In either case, the two principles must be
	 * strictly followed.
	 */
	AMCAX_API void ImportModel(const ShapeData &shape, const bool replace = true);

	/**
	 * @brief Load a stl model.
	 * @param filePath The stl file path to be imported.
	 * @param dihedralAngle When the dihedral angle of the patch is greater than
	 * dihedralAngle, divide it.
	 * @param curveAngle When the angle of the line segment is greater than
	 * curveAngle, segmentation is performed.
	 * @param mergeSmallPatchRatio Small patches with a proportion less than the
	 * given threshold will be merged into adjacent large patches.
	 * @param tolerance The points with coordinate difference less than the given
	 * tolerance will be considered as the same point.
	 */
	AMCAX_API void ImportSTL(const std::string &filePath,
	                         const double dihedralAngle, const double curveAngle,
	                         const double mergeSmallPatchRatio = 0.0,
	                         const double tolerance            = 0.0);

#ifdef INTERNAL_TEST
	// ----------------------- extrude entity -----------------------

	AMCAX_TEST_API NMEntity ExtrudeEntity(const std::vector<NMEntity> &entities,
	                                      const NMPoint3 &translation);

	AMCAX_TEST_API NMEntity SweepEntity(const std::vector<NMEntity> &entities,
	                                    const NMEntity              &alongEdge);

	AMCAX_TEST_API NMEntity RevolveEntity(const std::vector<NMEntity> &entities,
	                                      const NMPoint3              &axis,
	                                      const NMPoint3 &basis, double angle);

	/**
	 * @brief Add a vertex entity to the model.
	 *
	 * This function creates a vertex entity at the specified 3D coordinate `geo`.
	 * The behavior depends on the `onGeom` flag:
	 * - If `onGeom` is true:
	 *   - Projects `geo` onto the model's surface and creates the vertex at the
	 * projected point.
	 *   - Throws an exception if the distance between `geo` and the projected
	 * point exceeds `tolerance`.
	 * - If `onGeom` is false:
	 *   - Creates a discrete vertex entity at the exact input coordinate
	 * `geo`, not constrained to the model's geometry.
	 *
	 * @param geo The 3D coordinate where the vertex is intended to be created.
	 * @param onGeom If true, forces the vertex to lie on the model's surface via
	 * projection. If false, the vertex is treated as a discrete point.
	 * @param tolerance Maximum allowed distance between `geo` and the projected
	 * point when `onGeom` is true. Default: 1e-6. An exception is thrown if the
	 * distance exceeds this value.
	 * @return NMEntity The newly created vertex entity.
	 */
	AMCAX_TEST_API NMEntity AddVertexEntity(const NMPoint3 &geo,
	                                        const bool      onGeom    = false,
	                                        const double    tolerance = 1e-6);

	/**
	 * @brief Adds an edge entity between two vertices, optionally guided by a
	 * polyline path.
	 *
	 * This function creates an edge entity connecting the vertices `vbeg` and
	 * `vend`. The edge's geometry can be defined by an optional polyline `geo`.
	 * The behavior depends on the `onGeom` flag:
	 * - If `onGeom` is true:
	 *   - Projects the polyline `geo` (or the straight line between `vbeg` and
	 * `vend` if `geo` is empty) onto the model's surface and creates the edge
	 * along the projected path.
	 *   - Throws an exception if the maximum distance between the original `geo`
	 * and its projection exceeds `tolerance`.
	 * - If `onGeom` is false:
	 *   - Creates a discrete edge entity directly using the provided `geo` (or
	 * a straight line between `vbeg` and `vend` if `geo` is empty), without
	 * binding it to the model's geometry.
	 *
	 * @param vbeg The starting vertex entity of the edge.
	 * @param vend The ending vertex entity of the edge.
	 * @param geo Optional polyline defining the edge's path. If empty, a straight
	 * line between `vbeg` and `vend` is used.
	 * @param onGeom If true, projects the edge path onto the model's surface. If
	 * false, treats it as discrete edge.
	 * @param tolerance Maximum allowed projection distance when `onGeom` is true.
	 * Default: 1e-6.
	 * @return NMEntity The newly created edge entity.
	 */
	AMCAX_TEST_API NMEntity AddEdgeEntity(const NMEntity   &vbeg,
	                                      const NMEntity   &vend,
	                                      const NMPolyLine &geo       = {},
	                                      const bool        onGeom    = false,
	                                      const double      tolerance = 1e-6);

	/**
	 * @brief Adds a face entity (on model's surface) bounded by edges.
	 *
	 * This function creates a face entity enclosed by the boundary edges
	 * `bndEntities` with specified orientations `oris`. The boundary edges must
	 * be located at the model's surface. The orientations define the
	 * forward/reverse direction of each edge relative to the face, ensuring the
	 * face is topologically closed and consistent.
	 *
	 * @param bndEntities A list of boundary edge entities defining the face.
	 * @param oris Orientations of the boundary edges (e.g., forward/reverse) to
	 * determine the face's interior/exterior/. Internal means the inner edge.
	 * @return NMEntity The newly created face entity.
	 */
	AMCAX_TEST_API NMEntity
	AddFaceOnGeomEntity(const std::vector<NMEntity>    &bndEntities,
	                    const std::vector<Orientation> &oris);

	/**
	 * @brief Adds a discrete face entity (defined by a polygonal mesh geometry)
	 * bounded by edges.
	 *
	 * This function creates a face entity enclosed by the boundary edges
	 * `bndEntities` with specified orientations `oris`. The face's geometry is
	 * defined by the polygonal mesh `geo`. The orientations define the
	 * forward/reverse direction of each edge relative to the face, ensuring the
	 * face is topologically closed and consistent.
	 *
	 * @param bndEntities A list of boundary edge entities defining the face.
	 * @param oris Orientations of the boundary edges (e.g., forward/reverse) to
	 * determine the face's interior/exterior. Internal means the inner edge.
	 * @param geo Polygonal mesh defining the face's geometry.
	 * @return NMEntity The newly created face entity.
	 */
	AMCAX_TEST_API NMEntity AddDiscreteFaceEntity(
	  const std::vector<NMEntity>    &bndEntities,
	  const std::vector<Orientation> &oris, const NMPolyMesh &geo);

	/**
	 * @brief Adds a solid entity bounded by oriented face entities.
	 *
	 * This function creates a solid entity enclosed by a collection of boundary
	 * faces `bndEntities` with specified orientations `oris`. The orientations
	 * define the forward/reverse direction of each face relative to the solid,
	 * ensuring the volume is topologically closed and consistent.
	 * Throws an exception If:
	 *   - `bndEntities` and `oris` have mismatched sizes.
	 *   - The faces do not form a closed volume (e.g., gaps or overlaps exist).
	 *   - Face orientations are inconsistent (e.g., conflicting forward/reverse
	 * directions).
	 *
	 * @param bndEntities A list of boundary face entities defining the solid's
	 * surface. The faces with forward/reverse orientation must form a closed,
	 * watertight volume.
	 * @param oris Orientations of the boundary faces (e.g., forward/reverse) to
	 * determine the solid's interior/exterior. Must have the same size as
	 * `bndEntities`.  Internal means the inner face.
	 * @return NMEntity The newly created solid entity.
	 *
	 */
	AMCAX_TEST_API NMEntity
	AddSolidEntity(const std::vector<NMEntity>    &bndEntities,
	               const std::vector<Orientation> &oris);

	/**
	 * @brief Load a mesh model
	 * @param nmdat Shape represented in MeshData form
	 */
	AMCAX_TEST_API void ImportMeshModel(const MeshData &nmdat);
#endif

	// ----------------------- mesh -----------------------
	/**
	 * @brief Generates the mesh for the current model based on provided
	 * configuration parameters
	 * @param configJson A JSON-formatted string containing the control parameters
	 * for mesh generation
	 */
	AMCAX_API void GenerateMesh(const std::string &configJson);

	/**
	 * @brief Delete all the generated mesh. All the mesh handles are invalid
	 * after deleting mesh
	 */
	AMCAX_API void DeleteMesh();

	/**
	 * @brief Get the mesh handle. Note one model only holds a unique mesh.
	 * @return mesh handle
	 */
	AMCAX_API NMMesh GetMesh();

	/**
	 * @brief Get the mesh block handle.
	 * @return mesh block handle
	 */
	AMCAX_API NMBlock &GetNMBlock();

	// ----------------------- geometry -----------------------

	/** @brief Generate a composite entity by ignoring the boundary entities
	 * between the connected input
	 * @param entities The connected edge/face/solid entities
	 * @param ignoreAdjSubEntity Whether to ignore adjacent sub-entities on the
	 * boundaries of composite entities. For composite faces, ignore adjacent
	 * vertices; For composite solids, ignore adjacent edges and vertices.
	 * @return A composite entity if the input entities are connected, otherwise a
	 * invalid entity
	 */
	AMCAX_API NMEntity AddCompositeEntity(const std::vector<NMEntity> &entities,
	                                      bool ignoreAdjSubEntity = true);

	/// @brief Determine whether the input entity is valid
	/// @param ent The input entity
	/// @return True if ent is valid, otherwise false
	AMCAX_API bool IsValidEntity(const NMEntity &ent);

	/**
	 * @brief Remove a set of entities from the model
	 *
	 * For each entity in the removal set:
	 * Remove the entity and all entities that compose it. If the entity is not
	 * composite, the removal is skipped when the entity lies on the boundary of
	 * or is embedded within a higher-dimensional entity that must be preserved
	 *
	 * @param entities The entities to be removed
	 * @param recursive For non-composite entities: If true, remove the `entities`
	 * and all the entities on their boundary (or embeded in them), Otherwise,
	 * only remove the `entities`
	 */
	AMCAX_API void RemoveEntities(const std::vector<NMEntity> &entities,
	                              const bool                   recursive = false);

	/// @brief Get the entity handle by the input NMShape
	/// @param shape The input NMShape
	/// @return Entity handle. Only valid for vertex/edge/face/solid, otherwise,
	/// return nullptr
	AMCAX_API NMEntity GetEntityByShape(const NMShape &shape);

	/**
	 * @brief get all the entities in the specified dim
	 * @param ents the obtained entities
	 * @param dim dim =0 vertex; dim=1 edge; dim=2 face; dim=3 solid;
	 */
	AMCAX_API void GetEntities(std::vector<NMEntity> &ents, const DimType dim);

	/**
	 * @brief get the number of all entities in specified dim
	 * @param dim dim =0 vertex; dim=1 edge; dim=2 face; dim=3 solid; dim=-1 all
	 * shapes;
	 * @return the number of the obtained entities
	 */
	AMCAX_API Indext GetEntityCount(const DimType dim = DimType::DAll);

	/**
	 * @brief get the dimension of the given entity
	 * @param ent entity
	 * @return the dimension of the given entity
	 */
	AMCAX_API DimType EntityGetDim(const NMEntity &ent);

	/**
	 * @brief get the tag of the given entity
	 * @param ent entity
	 * @return the tag of the given entity
	 */
	AMCAX_API EntTag EntityGetTag(const NMEntity &ent);

	/**
	 * @brief get the entity handle by entity tag and dimension
	 * @param dim dimension
	 * @param etag entity tag
	 * @return entity handle
	 */
	AMCAX_API NMEntity GetEntity(const DimType dim, const EntTag etag);

	/**
	 * @brief get the boundingbox of the entity. when ent = nullptr, return the
	 * model bbox
	 * @param pmin min point of the boundingbox
	 * @param pmax max point of the boundingbox
	 * @param ent entity
	 */
	AMCAX_API void GetBBox(NMPoint3 &pmin, NMPoint3 &pmax,
	                       const NMEntity &ent = nullptr);

	/**
	 * @brief get the entities intersected with/enclosed by the given bbox
	 * @param entities the obtained entities
	 * @param pmin min point of the boundingbox
	 * @param pmax max point of the boundingbox
	 * @param isStrict if true, enclosed; otherwise, intersected.
	 * @param dim only consider the entity in given dim, if dim = -1,take all the
	 * shapes into account.
	 */
	AMCAX_API void GetEntitiesInBBox(std::vector<NMEntity> &entities,
	                                 const NMPoint3 &pmin, const NMPoint3 &pmax,
	                                 const bool    isStrict = false,
	                                 const DimType dim      = DimType::DAll);

	/**
	 * @brief get all the entities in dim+1 that contain the entity
	 * @param parents all the entities in dim+1 that contain the entity
	 * @param ent current entity
	 */
	AMCAX_API void GetParentAdjacentEntities(std::vector<NMEntity> &parents,
	                                         const NMEntity        &ent);

	/**
	 * @brief get all the entities in dim-1 contained by the entity
	 * @param children all the entities in dim-1 contained by the entity
	 * @param oris the orientations of all the children
	 * @param ent current entity
	 */
	AMCAX_API void GetChildAdjacentEntities(std::vector<NMEntity>    &children,
	                                        std::vector<Orientation> &oris,
	                                        const NMEntity           &ent);

	/**
	 * @brief the maximum dimension of the model
	 * @return max dim of the model
	 */
	AMCAX_API DimType GetModelMaxDim();

	/**
	 * @brief create a new physical set for the specified entities with specified
	 * dimension
	 * @param dim dimension
	 * @param entTags entity tags
	 * @param pName physicalset name
	 */
	AMCAX_API void CreatePhysicalSet(const DimType              dim,
	                                 const std::vector<EntTag> &entTags,
	                                 const std::string         &pName);
	/**
	 * @brief incrementally add entities into the specified physical set
	 * @param dim dimension
	 * @param entTags entity tags
	 * @param pName physicalset name
	 */
	AMCAX_API void AddPhysicalSet(const DimType              dim,
	                              const std::vector<EntTag> &entTags,
	                              const std::string         &pName);

	/**
	 * @brief remove the specified physical set
	 * @param dim dimension
	 * @param pName physicalset name
	 */
	AMCAX_API void RemovePhysicalSet(const DimType dim, const std::string &pName);

	/**
	 * @brief get entities in the specified physical set
	 * @param entTags entity tags
	 * @param dim dimension
	 * @param pName physicalset name
	 */
	AMCAX_API void GetEntitiesInPhysicalSet(std::vector<EntTag> &entTags,
	                                        const DimType        dim,
	                                        const std::string   &pName);

	/**
	 * @brief get all the physical sets in the specified dim
	 * @param pNames the physical set names
	 * @param dim dimension
	 */
	AMCAX_API void GetPhysicalSets(std::set<std::string> &pNames,
	                               const DimType          dim);

	// ----------------------- tools -----------------------
	/**
	 * @brief determine whether two face entities are in contact
	 * @param face1 face-entity-1
	 * @param face2 face-entity-2
	 * @param tolDist distance tolerance between two faces
	 * @param tolAng angle tolerances between the normals of two faces
	 * @return true if in contact, otherwise false
	 */
	AMCAX_API bool IsFacePairContacted(const NMEntity &face1,
	                                   const NMEntity &face2,
	                                   const double tolDist, const double tolAng);

	/**
	 * @brief set the logger. the logger is closed by default, if this function is
	 * not called
	 * @param logFileName if set, then output log to the file
	 * @param logPattern log pattern
	 * @param logFileSize the maximum size of a single file
	 * @param maxLogFiles the maximum number of files to keep
	 */
	AMCAX_API static void
	InitLogger(const std::string &logFileName = "",
	           const std::string &logPattern  = "[%Y-%m-%dT%X%z] [%l] %v",
	           const int64_t      logFileSize = 20 * 1024 * 1024,
	           const int          maxLogFiles = 100);

	/**
	 * @brief set the progressbar callback function
	 * @param cb callback function
	 */
	AMCAX_API static void SetProgressBarCallBack(PBCallBackFunc *cb);
	

private:
	std::shared_ptr<Model> model = nullptr;
};

} // namespace NextMesh
} // namespace AMCAX
